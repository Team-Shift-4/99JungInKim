# Oracle Redo와 Undo

## Redo

Data File과 Control File의 모든 변경 사항을 하나의 Redo Log Entry로써 Redo Log에 기록한다.
Redo Log는 Online Redo Log와 Archive Redo Log로 구성된다.
Online Redo Log는 Redo Log Buffer에 Buffering 된 Log Entry를 기록하는 파일이다.
현재 사용 중인 Redo Log File이 가득 차거나 Checkpoint나 alter system switch log file을 실행하면 Log Switching이 일어난다.
이때, Archive Mode가 켜져 있다면 Switching 된(지금까지 사용한 Online Redo Log) 파일을 새 파일로 내려 쓰며 이것이 Archive Log File이다.
Log Switching이 모든 Log File에 일어나 모든 Log File이 가득 차면 다시 첫 번째 Online Redo Log를 사용한다.(RR, Round Robin)

Round Robin이란 순서대로 시간 단위로 할당하는 기법이다.

Redo Log의 생성 이유는 크게 세 가지이다.

1.   DB Recovery
     -   물리적으로 디스크가 깨지는 Media Fail 장애 발생 시 DB Recovery를 위해 작성(Archive Log)
2.   Cache Recovery
     -   Cache에 저장된 변경 사항이 디스크 상의 데이터 블록에 아직 기록되지 않은 상태에서 정전 등이 발생해 Instance가 비정상 종료하게 되면 Buffer Cache에 있던 작업 내용이 모두 날아간다.(=Instance Crash)
     -   Instance Crash 후 시스템을 재기동하면 Online Redo Log에 기록된 정보들을 읽어 마지막 Checkpoint 이후부터 Instance Crash 이전까지 수행되었던 Transaction을 재현하는 데 사용(=Roll Forward)
3.   Fast Commit
     -   Memory Buffer Block을 디스크 상의 Data Block에 기록하는 작업은 Random Access지만 Redo Log는 Append 방식으로 기록하여 상대적으로 빨라 Log File에 기록하고 Memory Data Block과 Data File 간 동기화는 DBWR나 Checkpoint를 이용해 나중에 Batch 방식으로 일괄 수행한다.

## Undo

데이터 유실 방지를 위해 Redo Log와 같이 Logging

각 Transaction 별로 Undo Segment를 할댕해 Transaction이 발생시킨 Table과 Index에 대한 변경 사항을 Undo Record 단위로 Undo Segment에 기록한다.

Undo의 생성 이유는 크게 세 가지이다.

1.   Transaction Rollback
     -   Transaction에 의한 변경 사항을 Commit하지 않고 Rollback할 때 Undo Data를 사용
2.   Transaction Recovery
     -   Instance Crash 발생 후 Redo를 이용해 Roll Forward 단계가 완료되면 최종 Commit되지 않은 변경 사항까지 모두 복구할 때 사용
3.   Redo Consistency
     -   읽기 일관성 유지

## LGWR

LGWR Background Process는 Log Buffer에 있는 내용을 Log File에 기록한다.

기록 조건은 크게 네 가지이다.

1.   Commit
2.   Log Buffer가 1/3 찼을 때
3.   Log Buffer가 1MB 사용했을 때
4.   Timeout
     -   LGWR가 DBWR 보다 먼저 써야하기에 DBW가 작업을 시작할 때 LGWR에게 미리 신호를 발생

Log File의 상태는 네 가지이다.

1.   CURRENT: 현재 로그 정보를 기록 중
2.   ACTIVE: 기록 중이진 않으나 기록된 정보인 Dirty Block이 아직 DB Buffer Cache에 남아 있는 중
3.   INACTIVE: 사용 가능(사용 대기 중)
4.   UNUSED: INACTIVE와 동일하나 한번도 사용하지 않음

# Parsing

Parse: <낱말의> 품사·문법적 관계를 설명하다;<문장을> 해부[분석]하다.

Compile: <프로그램을> 다른 부호[기계어]로 번역하다.

Parse는 구문 분석이며 해당 SQL에 대한 분석을 통해 실행할 수 있는 단계를 만드는 것이다.
Soft Parsing과 Hard Parsing이 존재한다.

-   Soft Parsing: Shared Pool Library Cache에 저장된 정보를 재사용하여 바로 실행 단계로 넘어가는 경우이다.
-   Hard Parsing: Parse 과정과 최적화 과정을 다시 수행한 후 실행 단계로 넘어가는 경우이다.

SQL 문장의 실행 과정은 Parsing -> Optimization -> Row Source Generation -> Execute으로 진행된다.

1.   Parsing
     -   Syntax 검사(SQL 문장에 문법적 오류가 없는지 검사)
         -   Data Dictionary를 참조하여 확인하는 과정
         -   의미 상 오류가 없는지 확인
         -   SQL 문장에 사용된 Table이나 Column 이름이 정확한 지 확인
         -   SQL 문장을 사용하는 사용자가 해당 권한이 충분한 지 확인
2.   Optimization(최적화)
     -   실행 계획 생성(효율적으로 수행할 수 있는 다른 SQL 문장으로 내부적으로 변환 시키는 과정)
3.   Row Source Generation
     -   실행 계획을 실행 가능한 코드나 프로시저의 형태로 포맷팅하는 작업
     -   Row Source: Record Set을 반복 처리하며 사용자가 요구한 최종 Result Set을 실제적으로 생성하는 데 사용되는 제어 구조
4.   Execution
     -   SQL 문장들과 SQL 문장들의 실행 계획들이 Library Cache에 저장
     -   Library에 저장된 내용은 Shared Pool에 의해 같은 Instance를 사용하는 사용자들에게 공유 가능
     -   Library Cache에 이미 저장되어 있는 SQL 문장을 실행(=Soft Parsing)

# Cache와 Buffer

Cache: 자주 사용하는 Data나 Value를 미리 복사해 놓는 임시 저장 공간

Buffer: 속도 차이를 극복하기 위해 사용하는 임시 저장 공간