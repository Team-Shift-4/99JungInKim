위 문서는 PostgreSQL 11버전을 기반으로 작성되었다.

# PostgreSQL: Archive

항상 PostgreSQL은 클러스터 데이터 디렉터리의 `pg_wal` 하위 디렉터리에 WAL(Write Ahead Log, 이하 WAL)을 유지한다.
WAL는 DB의 데이터 파일에 대한 모든 변경 사항을 기록한다.
WAL는 주로 충돌 안전 목적에 의해 존재한다.
시스템이 충돌하면 마지막 체크포인트 이후 만들어진 WAL 항목을 재생하여 DB를 일관성 있게 복원한다.
복구가 필요한 경우 파일 시스템 백업을 복원한 후 백업된 WAL 파일에서 재생해 시스템을 현재 상태로 복원할 수 있다.
이 접근 방식은 다른 접근 방식들보다 관리하기 복잡하나 몇 가지 이점이 있다.

-   출발점으로 완벽하게 일관된 파일 시스템 백업이 필요하지 않다.
    -   백업의 내부 불일치는 WAL 재생으로 수정(응급 복구와 동일한 방법)된다.
    -   파일 시스템 스냅샷 기능이 필요하지 않고 tar와 같은 아카이빙 툴만 있으면 가능하다.
-   재생을 위해 무한히 긴 WAL 파일 시퀀스를 결합할 수 있으므로 WAL 파일을 계속 보관하는 것만으로 연속 백업을 수행할 수 있다.
    -   전체 백업을 자주 수행하지 못하는 대규모 데이터베이스에서 더욱 유용하다.
-   복원할 때 WAL 파일의 내용을 끝까지 재실행할 필요가 없다.
    -   특정 시점에서 이 작업을 멈출 수 있다는 말이며, 특정 시점의 DB 상태로 복원이 가능하다.
-   다른 호스트에 베이스 백업을 복원해 놓고 운영 서버에서 만들어지는 WAL 파일들을 주기적으로 준비해둔 서버로 반영할 수 있다.
    -   위 운영 방법을 Warm standby 시스템 구축 기법이라고 한다.

pg_dump와 pg_dumpall은 파일 시스템 수준 백업을 생성하지 않으며 연속 아카이빙 솔루션의 일부로 사용할 수 없다.
이러한 덤프는 논리적이며 WAL 재생에서 사용하기에 충분한 정보를 포함하지 않는다.

일반 파일 시스템 백업 기술과 마찬가지로 이 방법은 하위 집합이 아닌 전체 데이터베이스 클러스터의 복원만 지원할 수 있다.
많은 아카이브 스토리지 또한 필요로 하기에 기본 백업은 부피가 클 수 있으며 사용량이 많은 시스템은 아카이브 해야하는 많은 량의 WAL 트래픽을 생성한다.
높은 안정성이 필요한 많은 상황에서 사용되는 백업 기술이다.

Continuous Archiving(이하 연속 아카이빙, 온라인 백업)을 사용하여 성공적으로 복구하려면 적어도 백업 시작 시간까지 확장되는 Archived WAL 파일의 연속 시퀀스가 필요하다.

## WAL 아카이빙 설정

추상적인 의미에서 실행 중인 PostgreSQL 시스템은 무한정 긴 WAL 레코드 시퀀스를 생성한다.
시스템은 이 시퀀스를 일반적으로 각각 16MB인 WAL 세그먼트 파일로 물리적으로 나눈다(세그먼트 크기는 initdb 중 변경 가능).
세그먼트 파일에는 추상 WAL 시퀀스에서의 위치를 반영하는 숫자 이름이 지정된다.
WAL 아카이빙을 사용하지 않을 때 시스템은 일반적으로 몇 개의 세그먼트 파일만 생성한 후 더 이상 필요하지 않은 세그먼트 파일의 이름을 더 높은 세그먼트 번호로 변경해 재활용한다.
내용이 마지막 체크포인트보다 앞선 세그먼트 파일은 더 이상 관심 대상이 아니며 재활용 가능하다고 가정한다.

WAL 데이터를 보관할 때 채워진 각 세그먼트 파일의 내용을 캡처하고 세그먼트 파일이 재사용을 위해 재활용되기 전에 해당 데이터를 어딘가에 저장해야 한다.
DBA에게 유연성을 제공하기 위해 PostgreSQL은 아카이빙이 수행되는 방법에 대해 어떠한 가정도 하지 않는다.
대신 PostgreSQL을 통해 관리자는 완성된 세그먼트 파일을 필요한 곳으로 복사하기 위해 실행할 Shell 명령을 지정할 수 있다.
위 Shell 명령은 `cp`와 같이 단순할 수도 있고 복잡한 Shell 스크립트를 호출할 수도 있다.

WAL 아키이빙을 활성화하려면 postgresql.conf 파일의 wal_level 구성 매개 변수를 replica 이상, archive_mode를 on으로 설정하고 archive_command 구성 매개변수에서 사용할 쉘 명령을 지정하면 된다.
archive_command에서 %p는 아카이브할 파일의 경로 이름으로 대체되고 %f는 파일 이름만으로 대체된다(경로는 클러스터의 data에 상대적).
archive_command에서 %문자를 포함해야 하는 경우 %%와 같이 사용한다.

```shell
archive_command = 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'
```

아카이브 명령은 PostgreSQL 서버가 실행 중인 동일한 사용자의 소유권으로 실행된다.
아카이브되는 일련의 WAL 파일에는 Database의 모든 것이 효과적으로 포함한다.

아카이브 명령이 성공한 경우에만 종료 상태 0을 반환하는 것이 중요하다.
결과가 0일 경우 PostgreSQL은 파일이 성공적으로 보관되었다고 가정한 후 파일을 제거하거나 재활용한다.
결과가 0이 아닐 경우 PostgreSQL에 파일이 보관되지 않았음을 의미하며 성공할 때까지 주기적으로 다시 시도한다.

아카이브 명령은 일반적으로 기존 아카이브 파일을 덮어쓰지 않도록 설계되어야 한다.
이는 관리자 요류가 발생할 경우 아카이브의 무결성을 유지하는 중요한 안전 기능이다.
제안된 아카이브 명령을 테스트해 실제로 기존 파일을 덮어쓰지 않고 이 경우 0이 아닌 상태를 반환하는지 확인하는 것이 중요하다.

아카이브 명령을 작성할 때 아카이브할 파일 이름의 길이는 최대 64자이며 ASCII, 숫자, 점의 조합을 포함할 수 있다고 가정해야 한다.
원래 상대 경로(%p)를 유지할 필요는 없으나 원래 파일 이름(%f)은 유지해야 한다.

WAL 아카이빙을 사용하면 PostgreSQL DB의 데이터에 대한 수정 사항을 복원할 수 있으나 구성 파일에 변경 사항은 수동으로 편집되기 때문에 복원되지 않는다.
정기적인 파일 시스템 백업 절차에 의해 백업될 위치에 구성 파일을 보관할 수 있다.

아카이브 명령은 완료된 WAL 세그먼트에서만 호출된다.
따라서 서버가 WAL 트래픽을 거의 생성하지 않는 경우 트랜잭션 완료와 아카이브 스토리지의 안전한 기록 사이에 긴 지연이 있을 수 있다.
보관되지 않은 데이터가 얼마나 오래된 지에 대한 제한을 두려면 archive_timeout을 설정해 서버가 최소 그 빈도로 새 WAL 세그먼트 파일로 전환하도록 할 수 있다.
강제 전환으로 인해 초기에 아카이브된 아카이브 파일은 여전히 전체 파일과 동일한 길이이다.
따라서 짧은 archive_timeout을 설정할 경우 아카이브 저장 공간이 비효율적으로 사용된다.

방금 완료된 트랜잭션이 가능한 한 빨리 보관되도록 하려면 pg_switch_wal을 사용해 수동으로 세그먼트 전환을 강제할 수 있다.

archive_command가 빈 문자열('')일 경우 pg_wal에 누적된다.

